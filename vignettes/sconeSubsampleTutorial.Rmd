---
title: "Introduction to SCONE"
author: "Michael Cole and Davide Risso"
date: "`r Sys.Date()`"
bibliography: bibFile.bib
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteEncoding{UTF-8}
---

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{scone Vignette}
-->
First let's load the required libraries.

```{r sconeReport, eval= FALSE}
library(scone)

library(RColorBrewer)
library(shinycssloaders)
library(visNetwork)
library(plotly)
library(shiny)
```

Now let's create the large Scone object

```{r sconeReport, eval=FALSE}
# set.seed(2147)
# 
# ## ----- Control Genes ------
# 
# # Housekeeping Genes
# data("housekeeping")
# source(file = "prepDat.R")
# source(file = "prepDat_final.R")
# hk_final = rownames(prepDat_final)[fData(prepDat_final)$symbol %in% housekeeping$V1]
# 
# msigdb_path = "c7.all.v6.1.symbols.gmt"
# msig_db = readLines(msigdb_path)
# rm(msigdb_path)
# msig_db = strsplit(msig_db,split = "\t")
# getSet = function(entry_vec){
#   return(entry_vec[3:length(entry_vec)])
# }
# msig_sets = lapply(msig_db,getSet)
# getSetName = function(entry_vec){
#   return(entry_vec[1])
# }
# msig_set_names = unlist(lapply(msig_db,getSetName))
# rm(msig_db)
# names(msig_sets) = msig_set_names
# msig = msig_sets
# 
# implication_table = table(unlist(msig_sets))
# candidate_symbols = names(which(implication_table >= as.numeric(names(which(cumsum(rev(table(implication_table))) > 500)[1]))))
# candidate_markers = rownames(prepDat_final)[fData(prepDat_final)$symbol %in% candidate_symbols]
# 
# ## ----- Control Gene Sets -----
# 
# expr_final = as.matrix(exprs(prepDat_final))
# negcon = hk_final
# poscon = candidate_markers
# bothcon = intersect(negcon,poscon)
# negcon = negcon[!negcon %in% bothcon]
# poscon = poscon[!poscon %in% bothcon]
# 
# negcon_factor = factor(round(rowMeans(log2(1 + expr_final[negcon, ]))), levels = 0:10)
# poscon_factor = factor(round(rowMeans(log2(1 + expr_final[poscon, ]))), levels = 0:10)
# 
# bin_quotas = apply(cbind(floor(table(negcon_factor) / 2), floor(table(poscon_factor))), 1, min)
# bin_quotas = bin_quotas[bin_quotas > 0]
# 
# # Matched Mean Expression Negative Control Gene Sets
# negcon_eval = NULL
# poscon_eval = NULL
# negcon_ruv = NULL
# 
# for (i in as.numeric(names(bin_quotas))) {
#   negcon_bin = negcon[which(negcon_factor %in% as.character(i))]
#   poscon_bin = poscon[which(poscon_factor %in% as.character(i))]
#   
#   negcon_eval = c(negcon_eval,
#                   sample(x = negcon_bin,
#                          size = bin_quotas[as.character(i)]))
#   negcon_bin = negcon_bin[!negcon_bin %in% negcon_eval]
#   negcon_ruv = c(negcon_ruv,
#                  sample(x = negcon_bin,
#                         size = bin_quotas[as.character(i)]))
#   poscon_eval = c(poscon_eval,
#                   sample(x = poscon_bin,
#                          size = bin_quotas[as.character(i)]))
#   
# }
# stopifnot(all(apply(cbind(
#   table(factor(round(rowMeans(
#     log2( 1 + expr_final[negcon_eval, ])
#   )), levels = 0:10)),
#   table(factor(round(rowMeans(
#     log2(1 + expr_final[negcon_ruv, ])
#   )), levels = 0:10)),
#   table(factor(round(rowMeans(
#     log2(1 + expr_final[poscon_eval, ])
#   )), levels = 0:10))
# ), 1, var) == 0))
# 
# stopifnot(length(intersect(negcon_eval, negcon_ruv))  == 0)
# stopifnot(length(intersect(negcon_eval, poscon_eval))  == 0)
# stopifnot(length(intersect(poscon_eval, negcon_ruv))  == 0)
# 
# stopifnot(all(c(negcon_ruv,negcon_eval) %in% negcon))
# stopifnot(all(c(poscon_eval) %in% poscon))
# 
# rm(list = c("negcon", "poscon"))
# rm(list = c("hk_final"))
# 
# ## ----- QC -----
# qc_mat = read.table("10x_raw/pbmc4k_qc.txt", header = TRUE)
# rownames(qc_mat) = paste0(qc_mat$barcode,"-1")
# qc_4k = qc_mat[,-1][as.character(pData(prepDat_final)$barcode)[pData(prepDat_final)$batch  == "pbmc4k"],]
# qc_mat = read.table("10x_raw/pbmc8k_qc.txt", header = TRUE)
# rownames(qc_mat) = paste0(qc_mat$barcode,"-1")
# qc_8k = qc_mat[,-1][as.character(pData(prepDat_final)$barcode)[pData(prepDat_final)$batch  == "pbmc8k"],]
# 
# stopifnot(all(c(rownames(qc_8k),rownames(qc_4k)) == as.character(pData(prepDat_final)$barcode)))
# 
# qc = rbind(qc_8k,qc_4k)
# rownames(qc) = colnames(prepDat_final)
# ppq = scale(qc, center = TRUE, scale = TRUE)
# 
# ## ----- Scaling Argument -----
# 
# SCRAN_FN <- function(ei) {
#   sce <- SingleCellExperiment(list(counts=ei))
#   sce <- computeSumFactors(sce, sizes = seq(20, min(100,NCOL(ei)), 5))
#   sce <- normalize(sce,return_log = TRUE)
#   eo <- 2^logcounts(sce) - metadata(sce)$log.exprs.offset
#   return(eo)
# }
# 
# scaling = list(
#   none = identity,
#   sum = SUM_FN,
#   tmm = TMM_FN,
#   uq = UQ_FN,
#   fq = FQT_FN,
#   deseq = DESEQ_FN,
#   scran = SCRAN_FN
# )
# 
# ## ----- Scone For Each Technology -----
# 
# load(file = "seurat_ident.rda")
# clustering = factor(seurat_ident[colnames(expr_final)])
# 
# BiocParallel::register(BiocParallel::MulticoreParam(workers = 10)) # Register BiocParallel Serial Execution
# 
# # Creating a SconeExperiment Object
# scone_obj <- SconeExperiment(
#   expr_final,
#   batch = prepDat_final$batch,
#   bio = clustering,
#   qc = ppq,
#   negcon_ruv = rownames(expr_final) %in% negcon_ruv,
#   negcon_eval = rownames(expr_final) %in% negcon_eval,
#   poscon = rownames(expr_final) %in% poscon_eval
# )
# 
# k_ruv = ncol(ppq) - 1
# 
# scone_obj <- scone(
#   scone_obj ,
#   scaling = scaling,
#   k_qc = k_ruv,
#   k_ruv = k_ruv,
#   adjust_bio = "yes",
#   adjust_batch = "yes",
#   run = FALSE
# )
# 
subsampled_scone_1_scored <- scone(
  subsampled_scone_1,
  scaling = subsampled_scone_1@scaling_fn,
  k_qc = 8,
  k_ruv = 8,
  run = TRUE,
  zero = "postadjust",
  stratified_pam = FALSE,
  stratified_cor = FALSE,
  stratified_rle = FALSE,
  eval_kclust = 2:10,
  eval_pcs = 10,
  verbose = TRUE
)

subsampled_scone_2_scored <- scone(
  subsampled_scone_2,
  scaling = subsampled_scone_2@scaling_fn,
  k_qc = 8,
  k_ruv = 8,
  run = TRUE,
  zero = "postadjust",
  stratified_pam = FALSE,
  stratified_cor = FALSE,
  stratified_rle = FALSE,
  eval_kclust = 2:10,
  eval_pcs = 10,
  verbose = TRUE
)

load("scone_obj.rda")
scone_obj

```


Now let's subsample the scone object down to make it easier to load. Cell and gene level parameters subsample randomly by percentile. Keep all control genes ensures includes all control genes in the subsample. At bio controls wheter the subsampling crushes the cell groups down to the size of the smallest bio group, or the percentile size of that group.

```{r sconeReport, eval=FALSE}

# Delete Everything above, replace with making the larger scone object
subsampled_scone = subsample_scone(scone_obj, subsample_gene_level = 75,
                                   subsample_cell_level = 50, at_bio = FALSE,
                                   keep_all_control = TRUE,
                                   verbose = TRUE)
subsampled_scone

```

Now let's run the scone report on the new subsampled scone object. We set subsample to False in the call
to sconeReport because we don't want any more susbsampling to be done. Once in the report we can reenable
subsampling to do additional sampling.

```{r sconeReport, eval=FALSE}


# Methods to consider
scone_methods = c(rownames(get_params(subsampled_scone))[1:12])


# Shiny app
sconeReport(subsampled_scone,methods = scone_methods, subsample = FALSE)

```


# Session Info

```{r session}
sessionInfo()
```
